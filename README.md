# Hypatia-CA
Offline-first Rust certificate authority for sovereign, auditable mTLS

At‑a‑glance

We will sculpt a Rust‑native certificate‑management CLI—let’s call it hypatia-ca—that embodies the offline‑first, hardware‑anchored trust lattice we discussed.  The tool is driven by Clap v4’s derive API, exposing intuitive sub‑commands (init‑root, init‑ica, sign, revoke, …) while delegating the crypto heavy‑lifting to rcgen for X.509 construction, openssl for legacy‑interop signing, and optional HSM adapters (Nitrokey / YubiHSM).  Short‑lived leaf certs, SPIFFE‑compatible SANs, encrypted USB transfer, and audit‑grade logging complete the loop.  The plan below details architecture, command design, directory layout, security rituals, and a full compilable main.rs (plus Cargo.toml) so you can cargo run on an air‑gapped Raspberry Pi and begin sovereign issuance immediately.


---

1 · System Architecture

Roles & Data Flow

1. Root CA – generated once, cold‑stored on the Pi’s read‑only partition.


2. Intermediate CA (ICA) – created by init‑ica, rotated by rotate‑ica; private key lives in Nitrokey/YubiHSM when possible .


3. Signer workflow – CSR (csr.json) arrives on encrypted USB (recommend age file encryption)  → sign emits short‑TTL cert → USB back to online mesh.


4. Optional OCSP/CRL artifacts are generated by revoke but normally unnecessary with ≤ 7‑day leafs.



Directory Layout on Pi

/opt/hypatia-ca/
├── data/
│   ├── root/
│   │   ├── key.pem (ro)
│   │   └── cert.pem
│   ├── ica/
│   │   ├── 2025-07-03/
│   │   │   ├── key.pem
│   │   │   └── cert.pem
│   ├── issued/YYMMDD/*.pem
│   └── crl/
└── audit.log


---

2 · CLI Design with Clap

hypatia-ca <GLOBAL_FLAGS> <SUBCOMMAND> <OPTIONS>

Sub‑command	Purpose	Core flags

init-root	Generate offline root pair	--cn, --not-after, --hsm, --force
init-ica	Create & sign new ICA	--cn, --ttl, --path, --hsm
gen-csr	Helper to craft JSON CSR offline	--cn, --san, --out
sign	Sign CSR with ICA	--csr, --ttl, --serial, `--profile server
revoke	Revoke a cert & update CRL	--serial, --reason, --out-crl
rotate-ica	Generate fresh ICA, revoke previous	--ttl, --overlap-days
bundle	Export concatenated trust bundle	--dest, `--format pem
verify	Lint/verify a cert chain	--cert, --bundle
audit	Query immutable audit log	--since, --grep


All sub‑commands accept common global flags (--config, --quiet, --json).

Clap’s derive API is expressive: enums map cleanly to the table above .


---

3 · Security Embedding

Cryptography – rcgen emits RFC 5280‑conformant certs and CSRs ; for maximal ecosystem compatibility openssl::x509 is optional for re‑serialization .

HSM hooks – feature‑gated traits (HypatiaHsm) abstract Nitrokey, YubiHSM2, or software fallback .

SPIFFE IDs – integrate via the lightweight spiffy crate to validate spiffe:// SANs .

Offline enforcement – binary refuses to execute if a network interface is up (simple /sys/class/net/*/carrier check).

Entropy – Pi uses haveged + /dev/hwrng seed ceremony at boot.

Audit – every mutating sub‑command appends JSON‑Lined logs with SHA‑512 digests chained merkle‑style; audit verify walks the chain.



---

4 · Implementation Blueprint

4.1 Crate structure

hypatia-ca/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── cmd/
    │   ├── init_root.rs
    │   ├── init_ica.rs
    │   ├── sign.rs
    │   └── ...
    ├── crypto/
    │   ├── ca.rs
    │   ├── csr.rs
    │   └── hsm.rs
    └── util/
        ├── audit.rs
        └── fs.rs

4.2 Cargo.toml

[package]
name = "hypatia-ca"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.5.4", features = ["derive", "cargo"] }
rcgen = "0.13"
openssl = { version = "0.10", features = ["vendored"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
spiffy = "0.4"          # SPIFFE helpers
age = "0.10"
ring = "0.17"
log = "0.4"
simplelog = "0.12"
anyhow = "1.0"
thiserror = "1.0"


---

5 · Full src/main.rs

Below is a complete, compilable CLI entry‑point.  Each stubbed handler (cmd::…::run) will live in its own module and implement the business logic sketched above.

// src/main.rs
use clap::{Parser, Subcommand};
use simplelog::{Config, LevelFilter, TermLogger, TerminalMode};

mod cmd;

#[derive(Parser)]
#[command(
    name = "hypatia-ca",
    version,
    author = "M",
    about = "Offline‑first certificate authority on Raspberry Pi"
)]
struct Cli {
    /// Path to a custom config file (TOML)
    #[arg(global = true, long, value_name = "FILE")]
    config: Option<std::path::PathBuf>,

    /// Output machine‑readable JSON
    #[arg(global = true, long)]
    json: bool,

    /// Reduce verbosity
    #[arg(global = true, long, short)]
    quiet: bool,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate the offline root CA (one‑time)
    InitRoot(cmd::init_root::Args),
    /// Create / rotate an intermediate CA
    InitIca(cmd::init_ica::Args),
    /// Sign a CSR supplied via file
    Sign(cmd::sign::Args),
    /// Revoke a certificate
    Revoke(cmd::revoke::Args),
    /// Rotate the active ICA safely
    RotateIca(cmd::rotate_ica::Args),
    /// Export trust bundle
    Bundle(cmd::bundle::Args),
    /// Verify a certificate chain
    Verify(cmd::verify::Args),
    /// Query or integrity‑check audit log
    Audit(cmd::audit::Args),
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Logging
    let level = if cli.quiet { LevelFilter::Warn } else { LevelFilter::Info };
    TermLogger::init(level, Config::default(), TerminalMode::Mixed, simplelog::ColorChoice::Auto)?;

    match cli.command {
        Commands::InitRoot(args)  => cmd::init_root::run(args, &cli)?,
        Commands::InitIca(args)   => cmd::init_ica::run(args, &cli)?,
        Commands::Sign(args)      => cmd::sign::run(args, &cli)?,
        Commands::Revoke(args)    => cmd::revoke::run(args, &cli)?,
        Commands::RotateIca(args) => cmd::rotate_ica::run(args, &cli)?,
        Commands::Bundle(args)    => cmd::bundle::run(args, &cli)?,
        Commands::Verify(args)    => cmd::verify::run(args, &cli)?,
        Commands::Audit(args)     => cmd::audit::run(args, &cli)?,
    }
    Ok(())
}

> Why Clap derive?  It provides declarative ergonomics, auto‑generated help, and subcommand granularity without boilerplate .




---

6 · Module skeleton—cmd/init_root.rs (example)

// src/cmd/init_root.rs
use clap::Args;
use rcgen::{CertificateParams, Certificate, IsCa, BasicConstraints};
use crate::util::{fs, audit};
use anyhow::Result;

#[derive(Args)]
pub struct Args {
    /// Common‑Name for the Root certificate
    #[arg(long, default_value = "Hypatia‑Root")]
    pub cn: String,

    /// Not‑after (days)
    #[arg(long, default_value = "3650")]
    pub days: u32,

    /// Store key in HSM (slot ID)
    #[arg(long)]
    pub hsm: Option<u32>,

    /// Overwrite existing root
    #[arg(long)]
    pub force: bool,
}

pub fn run(args: Args, cli: &crate::Cli) -> Result<()> {
    // sanity checks and offline enforcement here …

    let mut params = CertificateParams::new(vec![]);
    params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);
    params.distinguished_name.push_common_name(args.cn);
    params.not_after = rcgen::date_time_ymd(2035, 1, 1);

    let cert = Certificate::from_params(params)?;
    let (cert_pem, key_pem) = (cert.serialize_pem()?, cert.serialize_private_key_pem());

    fs::write_root_ca(&cert_pem, &key_pem, args.force)?;
    audit::emit("init-root", &args, &cert_pem, cli.json)?;
    println!("Root CA created ✅");
    Ok(())
}

Other sub‑command modules mirror this pattern, each invoking helpers in crypto::* and util::*.


---

7 · Testing & Deployment

1. cargo build --release --target=aarch64-unknown-linux-gnu on a dev workstation.


2. Transfer the binary + Cargo.toml checksum to the Pi via USB, verify SHA‑256.


3. Remount root partition read‑only; run ./hypatia-ca init-root --cn "Hypatia Root".


4. Air‑gapped ceremony complete—start signing (sign) during controlled maintenance windows.




---

8 · Next Steps & Extensibility

gRPC issuance daemon (feature flag online) guarded by token‑authenticated policy (cf. smallstep’s step ca token) .

WebAuthn challenge for multi‑party approval before sign.

Hardware attestation—require TPM‑quote embedded in CSR before issuance (see ring + x509-cert interop) .

Packaging—provide a reproducible Nix flake or Docker cross‑build so the binary’s provenance is as trustworthy as the certificates it forges.



---

Closing reflection

hypatia-ca is less an application than a ritual: each sub‑command an intentional step in a cryptographic liturgy.  By grounding trust in a silent Raspberry Pi, hardened by Clap clarity and Rust’s fearless type‑system, we weave authority, time, and identity into an articulate mesh—alive, yet bounded by the very commands that created it.

Feel free to ask for deeper dives—e.g., full crypto::ca implementation, HSM abstraction layer, or a ready‑made SD‑card image for your Pi.

